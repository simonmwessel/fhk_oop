package de.fhkiel.oop

import de.fhkiel.oop.config.Config
import de.fhkiel.oop.config.DistributionConfig
import de.fhkiel.oop.config.GenerationParams
import de.fhkiel.oop.factory.FormFactory
import de.fhkiel.oop.mapper.CoordinateMapper
import de.fhkiel.oop.mapper.RelativeScaleMapper
import de.fhkiel.oop.mapper.UniformScaleMapper
import de.fhkiel.oop.model.BaseShape
import de.fhkiel.oop.model.ManipulatableShape
import de.fhkiel.oop.model.Vector2D
import de.fhkiel.oop.model.Shape
import de.fhkiel.oop.shapes.Circle
import de.fhkiel.oop.shapes.Rectangle
import de.fhkiel.oop.shapes.Square
import de.fhkiel.oop.utils.RandomUtils.Distribution
import processing.core.PApplet

/**
 * A Processing sketch that visualizes random shapes generated by the [FormFactory].
 *
 * This sketch ties together several components:
 *  - Canvas sizing based on [Config.MAX_X] and [Config.MAX_Y].
 *  - Shape generation via [FormFactory], producing instances of [Circle], [Rectangle], and [Square].
 *  - Distribution control for sizes and origins using [Distribution].
 *  - Rendering of shapes using Processing's drawing primitives provided by [PApplet].
 *
 * ## Mapper Modes
 * This sketch can operate in two different resizing strategies:
 *  - [UniformScaleMapper]: scales the entire scene uniformly, preserving aspect ratio.
 *  - [RelativeScaleMapper]: re-maps each shape to the current window size so that shapes “stick” to their
 *    relative edges, while circles and squares remain truly round/square.
 *
 * ## Workflow
 * 1. [settings] configures the sketch window size.
 * 2. [setup]    initializes color mode, background, resizability, and populates the [shapes] list.
 * 3. [draw]     clears the canvas each frame and renders each shape with its graphic attributes,
 *               using the selected resize strategy.
 *
 * @author  Simon Wessel
 * @version 1.8
 * @since   2.3
 *
 * @see Config
 * @see FormFactory
 * @see Distribution
 * @see PApplet
 * @see Shape
 * @see CoordinateMapper
 * @see RelativeScaleMapper
 * @see UniformScaleMapper
 */
class Sketch() : PApplet() {
    /**
     * The list of shapes to draw each frame.
     * Must not be empty.
     */
    private var _shapes: List<BaseShape>? = emptyList()
    var shapes: List<BaseShape>?
        /** Returns the list of shapes. */
        get() = _shapes
        /** Sets the list of shapes. */
        set(v) {
            _shapes = v
        }

    /**
     * Reference width for scaling calculations.
     * Must be > 0.
     */
    private var _baseW: Float = Config.MAX_X
    var baseW: Float
        /** Returns the base width for scaling calculations. */
        get() = _baseW
        /** Sets the base width for scaling calculations. */
        set(v) {
            require(v > 0f) { "Base width must be > 0" }
            _baseW = v
        }

    /**
     * Reference height for scaling calculations.
     * Must be > 0.
     */
    private var _baseH: Float = Config.MAX_Y
    var baseH: Float
        /** Returns the base height for scaling calculations. */
        get() = _baseH
        /** Sets the base height for scaling calculations. */
        set(v) {
            require(v > 0f) { "Base height must be > 0" }
            _baseH = v
        }

    /**
     * Minimum of [baseW] and [baseH], used for uniform scaling of circles and squares.
     * Must be > 0.
     */
    private var _baseMin: Float = min(_baseW, _baseH)
    var baseMin: Float
        /** Returns the base minimum for scaling calculations. */
        get() = _baseMin
        /** Sets the base minimum for scaling calculations. */
        set(v) {
            require(v > 0f) { "Base minimum must be > 0" }
            _baseMin = v
        }

    /**
     * Duration (in milliseconds) that the hint box remains visible.
     * Must be >= 0.
     */
    private var _hintDuration: Int = 5_000
    var hintDuration: Int
        /** Returns the hint duration. */
        get() = _hintDuration
        /** Sets the hint duration. */
        set(v) {
            require(v >= 0) { "Hint duration must be >= 0" }
            _hintDuration = v
        }

    /**
     * Timestamp (in milliseconds) when the hint was last shown.
     * Must be >= 0.
     */
    private var _hintStartTime: Int = 0
    var hintStartTime: Int
        /** Returns the hint start time. */
        get() = _hintStartTime
        /** Sets the hint start time. */
        set(v) {
            require(v >= 0) { "Hint start time must be >= 0" }
            _hintStartTime = v
        }

    /**
     * The coordinate mapper used for resizing and positioning shapes.
     * This can be either a [RelativeScaleMapper] or a [UniformScaleMapper].
     */
    private var _mapper: CoordinateMapper = RelativeScaleMapper(this, baseW, baseH, baseMin)
    var mapper: CoordinateMapper
        /** Returns the current coordinate mapper. */
        get() = _mapper
        /** Sets the coordinate mapper. */
        set(v) {
            require(v is RelativeScaleMapper || v is UniformScaleMapper) {
                "Mapper must be either RelativeScaleMapper or UniformScaleMapper"
            }
            _mapper = v
        }

    /** Backing field for the currently dragged shape. */
    private var _draggingShape: ManipulatableShape? = null

    /**
     * The currently dragged shape, if any.
     * This is used to track which shape is being moved during mouse drag events.
     */
    var draggingShape: ManipulatableShape?
        /** Returns the currently dragged shape, if any. */
        get() = _draggingShape
        /** Sets the currently dragged shape. */
        private set(v) {
            _draggingShape = v
            if (v != null) {
                _dragOffset = Vector2D(mouseX.toFloat() - v.origin.x, mouseY.toFloat() - v.origin.y)
            }
        }

    /** Backing field for the current drag offset. */
    private var _dragOffset: Vector2D = Vector2D(0f, 0f)

    /**
     * The current drag offset, which is the difference between the mouse position
     * and the origin of the currently dragged shape.
     *
     * This is used to maintain the relative position of the shape during dragging.
     */
    var dragOffset: Vector2D
        /** Returns the current drag offset. */
        get() = _dragOffset
        /** Sets the drag offset. */
        private set(v) {
            _dragOffset = v
        }

    /**
     * Configures the initial size of the sketch window based on [baseW] and [baseH].
     */
    override fun settings() = size(baseW.toInt(), baseH.toInt())

    /**
     * Initializes the sketch:
     *
     * Configures the color mode to RGB.
     * Enables window resizability.
     * Generates a list of random shapes via [FormFactory.produce], using
     * [Distribution.NORMAL] for sizes and [Distribution.UNIFORM] for origins.
     *
     * @see FormFactory.produce
     * @see Distribution
     */
    override fun setup() {
        colorMode(RGB, 255f)

        surface.setResizable(true)

        addShapes(GenerationParams.RANDOM_20)

        hintStartTime = millis()

        if (!shapes.isNullOrEmpty()) {
            println("\nFollowing shapes were sketched:")
            for (shape in shapes) println(shape)
        }
    }

    /**
     * Handles window resizing by delegating to the active [CoordinateMapper] strategy.
     *
     * For [UniformScaleMapper]:
     * 1. Calculates single scale factor from the smallest dimension
     * 2. Centers content with black borders
     * 3. Applies uniform scaling
     *
     * For [RelativeScaleMapper]:
     * 1. Scales positions by window/base ratios
     * 2. Scales circles/squares by min(windowAspectRatio, baseAspectRatio)
     * 3. Scales rectangles proportionally to window
     */
    override fun draw() {
        background(
            Config.SKETCH_BACKGROUND_COLOR.red,
            Config.SKETCH_BACKGROUND_COLOR.green,
            Config.SKETCH_BACKGROUND_COLOR.blue
        )

        shapes?.forEach {
            try {
                it.draw(this, mapper)
            } catch (e: Exception) {
                println("Error drawing shape: ${it.javaClass.simpleName} at ${it.origin} with style ${it.style}:\n${e.message}")
            }
        }

        drawHint()
    }

    /**
     * Renders a semi-transparent hint box with instructions to toggle the resize mode.
     *
     * The hint is displayed for [hintDuration] milliseconds starting from [hintStartTime].
     */
    private fun drawHint() {
        if (millis() - hintStartTime >= hintDuration) return

        pushStyle()

        val resizeMode = when (mapper) {
            is RelativeScaleMapper -> "Relative"
            is UniformScaleMapper  -> "Uniform Scale"
        }

        val debugMode = if (Config.DEBUG) "on" else "off"

        val lines = listOf(
            "Press 'M' to toggle resize mode",
            "(current: $resizeMode)",
            "Press 'S' to add a square",
            "Press 'R' to add a rectangle",
            "Press 'C' to add a circle",
            "Press 'D' to toggle debug mode (current: $debugMode)"
        )

        textSize(16f)
        textAlign(CENTER, TOP)
        val lineHeight = textAscent() + textDescent()
        val padding = 8f
        val maxWidth = lines.maxOf { textWidth(it) }

        val boxWidth = maxWidth + padding * 2
        val boxHeight = lines.size * lineHeight + padding * 2
        val boxX = width / 2f - boxWidth / 2f
        val boxY = 10f

        noStroke()
        fill(255f, 255f, 255f, 180f)
        rect(boxX, boxY, boxWidth, boxHeight)

        fill(0f)
        lines.forEachIndexed { index, line ->
            text(line, width / 2f, boxY + padding + index * lineHeight)
        }

        popStyle()
    }

    /**
     * Adds a specified number of shapes to the existing list of shapes.
     *
     * Delegates shape generation logic entirely to [FormFactory.produce].
     * The new shapes are appended to the current [_shapes] list.
     *
     * @param generationParams The parameters for generating shapes, as defined in [GenerationParams].
     *   This includes `count` (must be > 0), `shapeType` (if null, random shapes are generated),
     *   `safe` (for bounds checking), and `size`/`origin` ([DistributionConfig]) settings.
     * @see FormFactory.produce
     * @see GenerationParams
     */
    fun addShapes(generationParams: GenerationParams) {
        require(generationParams.count > 0) { "Number of shapes to add must be > 0" }

        val newShapes = FormFactory().produce(
            generationParams = generationParams,
            sizeConfig       = generationParams.size,
            originConfig     = generationParams.origin,
        )
        shapes = if (shapes.isNullOrEmpty()) newShapes
                 else shapes!!.toMutableList().apply { addAll(newShapes) }

        val typeDescription = generationParams.shapeType?.name?.lowercase()?.replaceFirstChar {
            if (it.isLowerCase()) it.titlecase() else it.toString()
        } ?: "random"

        println("\nAdded ${generationParams.count} new ${typeDescription}(s). Total shapes: ${_shapes!!.size}")
        newShapes.forEach { println(it) }
    }

    /**
     * Handles key presses for various actions:
     *
     * - 'M' / 'm': Toggle between [RelativeScaleMapper] and [UniformScaleMapper].
     *   @see de.fhkiel.oop.mapper.RelativeScaleMapper
     *   @see de.fhkiel.oop.mapper.UniformScaleMapper
     *
     * - 'Q' / 'q': Add a new [Square] via [FormFactory.produce].
     *   @see de.fhkiel.oop.shapes.Square
     *   @see de.fhkiel.oop.config.GenerationParams.SQUARE
     *
     * - 'V' / 'v': Add a new [Rectangle] via [FormFactory.produce].
     *   @see de.fhkiel.oop.shapes.Rectangle
     *   @see de.fhkiel.oop.config.GenerationParams.RECTANGLE
     *
     * - 'K' / 'k': Add a new [Circle] via [FormFactory.produce].
     *   @see de.fhkiel.oop.shapes.Circle
     *   @see de.fhkiel.oop.config.GenerationParams.CIRCLE
     *
     * - 'R', 'G', 'B' (case‐sensitive): Adjust the **fill** color components of **all selected** shapes.
     *   Uppercase increases by 5 units; lowercase decreases by 5 units.
     *   Channels are clamped to [0..255].
     *   @see de.fhkiel.oop.model.Style
     *   @see de.fhkiel.oop.utils.Color
     *
     * - '0'..'9': Set the **stroke weight** (in pixels) of **all selected** shapes.
     *   Values below [Config.MIN_STRK_WEIGHT] (.5f) will be clamped to it.
     *   @see de.fhkiel.oop.config.Config.MIN_STRK_WEIGHT
     *
     * - 'D' / 'd': Toggle [Config.DEBUG].
     *   @see de.fhkiel.oop.config.Config
     *
     * - 'H' / 'h': Show the hint box for a longer duration.
     *   @see drawHint
     */
    override fun keyPressed() {
        // Convert key to uppercase for consistent handling
        if (keyCode.toChar() == DELETE) {
            if (shapes.isNullOrEmpty()) {
                println("No shapes to delete.")
                return
            }
            val toRemove = shapes!!
                .filterIsInstance<ManipulatableShape>()
                .filter { it.isSelected }

            if (toRemove.isNotEmpty()) {
                shapes = shapes!!.toMutableList().apply { removeAll(toRemove) }

                if (draggingShape != null && toRemove.contains(draggingShape)) draggingShape = null

                println("Deleted ${toRemove.size} shape(s). Remaining: ${shapes!!.size}")
            }
            return
        }

        val selected = shapes
            ?.filterIsInstance<ManipulatableShape>()
            ?.filter { it.isSelected }
            .orEmpty()

        // Color adjustments using Color.increment*/decrement*
        when (key) {
            'R' -> selected.forEach { it.inner.style.fill = it.inner.style.fill.incrementRed() }
            'r' -> selected.forEach { it.inner.style.fill = it.inner.style.fill.decrementRed() }
            'G' -> selected.forEach { it.inner.style.fill = it.inner.style.fill.incrementGreen() }
            'g' -> selected.forEach { it.inner.style.fill = it.inner.style.fill.decrementGreen() }
            'B' -> selected.forEach { it.inner.style.fill = it.inner.style.fill.incrementBlue() }
            'b' -> selected.forEach { it.inner.style.fill = it.inner.style.fill.decrementBlue() }
        }

        // Stroke weight adjustment
        if (key in '0'..'9') {
            val weightPx = key.digitToInt().toFloat().coerceAtLeast(Config.MIN_STRK_WEIGHT)
            selected.forEach { it.inner.style.weight = weightPx }
            return
        }

        // Other shortcuts
        when (key.lowercaseChar()) {
            'm' -> mapper =
                if (mapper is RelativeScaleMapper) UniformScaleMapper(this, baseW, baseH)
                else RelativeScaleMapper(this, baseW, baseH, baseMin)
            'q' -> addShapes(GenerationParams.SQUARE)
            'v' -> addShapes(GenerationParams.RECTANGLE)
            'k' -> addShapes(GenerationParams.CIRCLE)
            'd' -> Config.DEBUG = !Config.DEBUG
            'h' -> {
                hintStartTime = millis()
                hintDuration  = 10_000
            }
        }
    }

    /**
     * Handles mouse clicks to toggle selection of shapes.
     *
     * When the user clicks on a shape, it toggles its selection state.
     * If the SHIFT key is not pressed, all other shapes are deselected first.
     *
     * Uses hit detection based on the current [CoordinateMapper] to determine which shape was clicked.
     */
    override fun mousePressed() {
        if (shapes.isNullOrEmpty()) {
            println("No shapes to select.")
            return
        }
        // Hit detection
        val hit = shapes!!
            .filterIsInstance<ManipulatableShape>()
            .asReversed()
            .firstOrNull { it.hitTestScreen(this.mapper, mouseX.toFloat(), mouseY.toFloat()) }

        // Handle selection toggle
        if (!keyPressed || keyCode != SHIFT)
            shapes!!.filterIsInstance<ManipulatableShape>().forEach { it.isSelected = false }

        hit?.let { ms ->
            ms.isSelected = !ms.isSelected

            if (ms.isSelected) {
                draggingShape = ms
                val worldMouseVector = mapper.screenToWorld(Vector2D(mouseX.toFloat(), mouseY.toFloat()))
                dragOffset = Vector2D(worldMouseVector.x - ms.inner.origin.x, worldMouseVector.y - ms.inner.origin.y)
            } else draggingShape = null
        }
    }

    override fun mouseDragged() {
        val worldMouseVector = mapper.screenToWorld(Vector2D(mouseX.toFloat(), mouseY.toFloat()))
        val ms = draggingShape ?: return

        val desired = Vector2D(worldMouseVector.x - dragOffset.x, worldMouseVector.y - dragOffset.y)

        val clamped = ms.inner.strategies.moveConstraint
            .clampOrigin(desired, ms.inner)

        try {
            ms.inner.origin = clamped
        } catch (e: Exception) {
            println("Error dragging shape: ${ms.inner.javaClass.simpleName} at $desired:\n${e.message}")
        }
    }

    override fun mouseReleased() {
        draggingShape = null
        dragOffset = Vector2D(0f, 0f)
    }
}
