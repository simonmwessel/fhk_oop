package de.fhkiel.oop

import de.fhkiel.oop.config.Config
import de.fhkiel.oop.factory.FormFactory
import de.fhkiel.oop.model.BaseShape
import de.fhkiel.oop.model.Shape
import de.fhkiel.oop.shapes.Circle
import de.fhkiel.oop.shapes.Rectangle
import de.fhkiel.oop.shapes.Square
import de.fhkiel.oop.utils.RandomUtils.Distribution
import processing.core.PApplet

/**
 * A Processing sketch that visualizes random shapes generated by the [FormFactory].
 *
 * This sketch ties together several components:
 *  - Canvas sizing based on [Config.MAX_X] and [Config.MAX_Y].
 *  - Shape generation via [FormFactory], producing instances of [Circle], [Rectangle], and [Square].
 *  - Distribution control for sizes and origins using [Distribution].
 *  - Rendering of shapes using Processing's drawing primitives provided by [PApplet].
 *
 * ## Resize Modes
 * This sketch can operate in two different resizing strategies:
 *  - [ResizeMode.UNIFORM_SCALE]: scales the entire scene uniformly, preserving aspect ratio.
 *  - [ResizeMode.RELATIVE]: re-maps each shape to the current window size so that shapes “stick” to their
 *    relative edges, while circles and squares remain truly round/square.
 *
 * ## Workflow
 * 1. [settings] configures the sketch window size.
 * 2. [setup]    initializes color mode, background, resizability, and populates the [shapes] list.
 * 3. [draw]     clears the canvas each frame and renders each shape with its graphic attributes,
 *               using the selected resize strategy.
 *
 * @param resizeMode determines which resizing strategy to apply when the window is resized.
 *
 * @author  Simon Wessel
 * @version 1.3
 * @since   2.3
 *
 * @see ResizeMode
 * @see Config
 * @see FormFactory
 * @see Distribution
 * @see PApplet
 * @see Shape
 */
class Sketch(
    initialResizeMode: ResizeMode = ResizeMode.RELATIVE
) : PApplet() {

    /**
     * The current resize mode used by the sketch.
     * Can be toggled between [ResizeMode.UNIFORM_SCALE] and [ResizeMode.RELATIVE].
     */
    private var _resizeMode: ResizeMode = initialResizeMode
    var resizeMode: ResizeMode
        /** Returns the current resize mode. */
        get() = _resizeMode
        /** Sets the resize mode. */
        set(v) {
            _resizeMode = v
        }

    /**
     * The list of shapes to draw each frame.
     * Must not be empty.
     */
    private var _shapes: List<BaseShape> = emptyList()
    var shapes: List<BaseShape>
        /** Returns the list of shapes. */
        get() = _shapes
        /** Sets the list of shapes. */
        set(v) {
            require(v.isNotEmpty()) { "Shapes list must not be empty" }
            _shapes = v
        }

    /**
     * Reference width for scaling calculations.
     * Must be > 0.
     */
    private var _baseW: Float = Config.MAX_X
    var baseW: Float
        /** Returns the base width for scaling calculations. */
        get() = _baseW
        /** Sets the base width for scaling calculations. */
        set(v) {
            require(v > 0f) { "Base width must be > 0" }
            _baseW = v
        }

    /**
     * Reference height for scaling calculations.
     * Must be > 0.
     */
    private var _baseH: Float = Config.MAX_Y
    var baseH: Float
        /** Returns the base height for scaling calculations. */
        get() = _baseH
        /** Sets the base height for scaling calculations. */
        set(v) {
            require(v > 0f) { "Base height must be > 0" }
            _baseH = v
        }

    /**
     * Minimum of [baseW] and [baseH], used for uniform scaling of circles and squares.
     * Must be > 0.
     */
    private var _baseMin: Float = min(_baseW, _baseH)
    var baseMin: Float
        /** Returns the base minimum for scaling calculations. */
        get() = _baseMin
        /** Sets the base minimum for scaling calculations. */
        set(v) {
            require(v > 0f) { "Base minimum must be > 0" }
            _baseMin = v
        }

    /**
     * Duration (in milliseconds) that the hint box remains visible.
     * Must be >= 0.
     */
    private var _hintDuration: Int = 3_000
    var hintDuration: Int
        /** Returns the hint duration. */
        get() = _hintDuration
        /** Sets the hint duration. */
        set(v) {
            require(v >= 0) { "Hint duration must be >= 0" }
            _hintDuration = v
        }

    /**
     * Timestamp (in milliseconds) when the hint was last shown.
     * Must be >= 0.
     */
    private var _hintStartTime: Int = 0
    var hintStartTime: Int
        /** Returns the hint start time. */
        get() = _hintStartTime
        /** Sets the hint start time. */
        set(v) {
            require(v >= 0) { "Hint start time must be >= 0" }
            _hintStartTime = v
        }

    /**
     * Defines strategies for handling window resizing:
     *
     * - [UNIFORM_SCALE]: Centers and scales the entire scene proportionally
     * - [RELATIVE]: Maps shapes to window coordinates while preserving:
     *   - Circle/square roundness
     *   - Rectangle aspect ratios
     *   - Relative positional relationships
     */
    enum class ResizeMode {
        /** Scale whole scene uniformly around center. */
        UNIFORM_SCALE,

        /** Map shapes to relative window coords, preserving individual aspect constraints. */
        RELATIVE
    }

    /**
     * Configures the initial size of the sketch window based on [baseW] and [baseH].
     */
    override fun settings() = size(baseW.toInt(), baseH.toInt())

    /**
     * Initializes the sketch:
     *
     * Configures the color mode to RGB.
     * Enables window resizability.
     * Generates a list of random shapes via [FormFactory.produce], using
     * [Distribution.NORMAL] for sizes and [Distribution.UNIFORM] for origins.
     *
     * @see FormFactory.produce
     * @see Distribution
     */
    override fun setup() {
        colorMode(RGB, 255f)

        surface.setResizable(true)

        shapes = FormFactory().produce(
            count            = 40,
            safe             = true,
            sizeDist         = Distribution.NORMAL,
            sizePeakFraction = .2f,
            originDist       = Distribution.UNIFORM
        )

        hintStartTime = millis()

        println("\nFollowing shapes were sketched:")
        for (shape in shapes) println(shape)
    }

    /**
     * Handles window resizing by delegating to the active [ResizeMode] strategy.
     *
     * For [ResizeMode.UNIFORM_SCALE]:
     * 1. Calculates single scale factor from the smallest dimension
     * 2. Centers content with black borders
     * 3. Applies uniform scaling
     *
     * For [ResizeMode.RELATIVE]:
     * 1. Scales positions by window/base ratios
     * 2. Scales circles/squares by min(windowAspectRatio, baseAspectRatio)
     * 3. Scales rectangles proportionally to window
     */
    override fun draw() {
        background(
            Config.SKETCH_BACKGROUND_COLOR.red,
            Config.SKETCH_BACKGROUND_COLOR.green,
            Config.SKETCH_BACKGROUND_COLOR.blue
        )

        when (resizeMode) {
            ResizeMode.UNIFORM_SCALE -> {
                val f    = min(width / baseW, height / baseH)
                val offX = (width  - baseW * f) / 2f
                val offY = (height - baseH * f) / 2f

                pushMatrix()
                translate(offX, offY)
                scale(f)

                shapes.forEach { it.drawUniform(this) }

                popMatrix()
            }
            ResizeMode.RELATIVE -> {
                val sx  = width  / baseW
                val sy  = height / baseH
                val us  = min(width, height) / baseMin

                shapes.forEach { it.drawRelative(this, sx, sy, us) }
            }
        }

        drawHint()
    }

    /**
     * Renders a semi-transparent hint box with instructions to toggle the resize mode.
     *
     * The hint is displayed for [hintDuration] milliseconds starting from [hintStartTime].
     */
    private fun drawHint() {
        if (millis() - hintStartTime >= hintDuration) return

        pushStyle()

        val lines = listOf(
            "Press 'M' to toggle resize mode",
            "(current: $resizeMode)"
        )

        textSize(16f)
        textAlign(CENTER, TOP)
        val lineHeight = textAscent() + textDescent()
        val padding = 8f
        val maxWidth = lines.maxOf { textWidth(it) }

        val boxWidth = maxWidth + padding * 2
        val boxHeight = lines.size * lineHeight + padding * 2
        val boxX = width / 2f - boxWidth / 2f
        val boxY = 10f

        noStroke()
        fill(255f, 255f, 255f, 180f)
        rect(boxX, boxY, boxWidth, boxHeight)

        fill(0f)
        lines.forEachIndexed { index, line ->
            text(line, width / 2f, boxY + padding + index * lineHeight)
        }

        popStyle()
    }

    /**
     * Toggles the [resizeMode] when the user presses 'M' or 'm',
     * and restarts the hint timer.
     */
    override fun keyPressed() {
        if (key == 'm' || key == 'M') {
            resizeMode = when (resizeMode) {
                ResizeMode.UNIFORM_SCALE -> ResizeMode.RELATIVE
                ResizeMode.RELATIVE      -> ResizeMode.UNIFORM_SCALE
            }
            hintStartTime = millis()
        }
    }
}
