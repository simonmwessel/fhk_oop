package de.fhkiel.oop

import de.fhkiel.oop.config.Config
import de.fhkiel.oop.config.DistributionConfig
import de.fhkiel.oop.config.GenerationParams
import de.fhkiel.oop.factory.FormFactory
import de.fhkiel.oop.mapper.CoordinateMapper
import de.fhkiel.oop.mapper.RelativeScaleMapper
import de.fhkiel.oop.mapper.UniformScaleMapper
import de.fhkiel.oop.model.InteractiveShape
import de.fhkiel.oop.model.Vector2D
import de.fhkiel.oop.model.Shape
import de.fhkiel.oop.shapes.Circle
import de.fhkiel.oop.shapes.Rectangle
import de.fhkiel.oop.shapes.Square
import de.fhkiel.oop.utils.RandomUtils.Distribution
import processing.core.PApplet
import de.fhkiel.oop.sketch.config.SketchConfig
import de.fhkiel.oop.sketch.config.HintConfig
import de.fhkiel.oop.sketch.state.ShapeState
import de.fhkiel.oop.sketch.state.InteractionState
import de.fhkiel.oop.sketch.state.MapperState

/**
 * A Processing sketch that visualizes random shapes generated by the [FormFactory].
 *
 * This sketch ties together several components:
 *  - Canvas sizing based on [Config.MAX_X] and [Config.MAX_Y].
 *  - Shape generation via [FormFactory], producing instances of [Circle], [Rectangle], and [Square].
 *  - Distribution control for sizes and origins using [Distribution].
 *  - Rendering of shapes using Processing's drawing primitives provided by [PApplet].
 *
 * ## Mapper Modes
 * This sketch can operate in two different resizing strategies:
 *  - [UniformScaleMapper]: scales the entire scene uniformly, preserving aspect ratio.
 *  - [RelativeScaleMapper]: re-maps each shape to the current window size so that shapes “stick” to their
 *    relative edges, while circles and squares remain truly round/square.
 *
 * ## Workflow
 * 1. [settings] configures the sketch window size.
 * 2. [setup]    initializes color mode, background, resizability, and populates the [shapes] list.
 * 3. [draw]     clears the canvas each frame and renders each shape with its graphic attributes,
 *               using the selected resize strategy.
 *
 * @author  Simon Wessel
 * @version 1.8
 * @since   2.3
 *
 * @see Config
 * @see FormFactory
 * @see Distribution
 * @see PApplet
 * @see Shape
 * @see CoordinateMapper
 * @see RelativeScaleMapper
 * @see UniformScaleMapper
 */
class Sketch() : PApplet() {
    /** Configuration for sketch canvas properties like base width, height, and derived minimum dimension. */
    private val sketchConfig = SketchConfig()

    /** Configuration for on-screen hint box visibility, such as duration and start time. */
    private val hintConfig = HintConfig()

    /** State holder for the list of shapes to be drawn on the canvas. */
    private val shapeState = ShapeState()

    /** State holder for user interactions, including dragging and resizing of shapes. */
    private val interactionState = InteractionState()

    /** State holder for the coordinate mapper strategy, initialized with current sketch dimensions. */
    private val mapperState = MapperState(
        this,
        sketchConfig.baseWidth,
        sketchConfig.baseHeight,
        sketchConfig.baseMin
    )

    /**
     * Configures the initial size of the sketch window based on [sketchConfig].
     */
    override fun settings() = size(sketchConfig.baseWidth.toInt(), sketchConfig.baseHeight.toInt())

    /**
     * Initializes the sketch:
     *
     * Configures the color mode to RGB.
     * Enables window resizability.
     * Generates a list of random shapes via [FormFactory.produce], using
     * [Distribution.NORMAL] for sizes and [Distribution.UNIFORM] for origins.
     *
     * @see FormFactory.produce
     * @see Distribution
     */
    override fun setup() {
        colorMode(RGB, 255f)

        surface.setResizable(true)

        addShapes(GenerationParams.RANDOM_20)

        hintConfig.startTime = millis()

        if (!shapeState.shapes.isNullOrEmpty()) {
            println("\\nFollowing shapes were sketched:")
            for (shape in shapeState.shapes!!) println(shape)
        }
    }

    /**
     * Handles window resizing by delegating to the active [CoordinateMapper] strategy.
     *
     * For [UniformScaleMapper]:
     * 1. Calculates single scale factor from the smallest dimension
     * 2. Centers content with black borders
     * 3. Applies uniform scaling
     *
     * For [RelativeScaleMapper]:
     * 1. Scales positions by window/base ratios
     * 2. Scales circles/squares by min(windowAspectRatio, baseAspectRatio)
     * 3. Scales rectangles proportionally to window
     */
    override fun draw() {
        background(
            Config.SKETCH_BACKGROUND_COLOR.red,
            Config.SKETCH_BACKGROUND_COLOR.green,
            Config.SKETCH_BACKGROUND_COLOR.blue
        )

        shapeState.shapes?.forEach {
            try {
                it.draw(this, mapperState.mapper)
            } catch (e: Exception) {
                println("Error drawing shape: ${it.javaClass.simpleName} at ${it.origin} with style ${it.style}:\\n${e.message}")
            }
        }

        drawHint()
        drawStatusBar()
    }

    /**
     * Renders a semi-transparent hint box with instructions to toggle the resize mode.
     */
    private fun drawHint() {
        if (millis() - hintConfig.startTime >= hintConfig.duration) return

        pushStyle()

        val pad = 8f
        val startX = pad
        val startY = pad

        // Determine current modes
        val resizeMode = when (mapperState.mapper) {
            is RelativeScaleMapper -> "Relative"
            is UniformScaleMapper  -> "Uniform Scale"
        }
        val debugMode = if (Config.DEBUG) "on" else "off"

        // Hint entries: key to action description
        val entries = listOf(
            "M" to "Toggle resize mode (current: $resizeMode)",
            "S" to "Add square",
            "V" to "Add rectangle",
            "K" to "Add circle",
            "R" to "Increase red",
            "r" to "Decrease red",
            "G" to "Increase green",
            "g" to "Decrease green",
            "B" to "Increase blue",
            "b" to "Decrease blue",
            "0-9" to "Set stroke weight",
            "D" to "Toggle debug (current: $debugMode)",
            "H" to "Show hint longer",
            "DEL" to "Delete selected shapes"
        )

        textSize(16f)
        textAlign(LEFT, TOP)
        val lineHeight = textAscent() + textDescent()

        // Measure maximum widths for keys and descriptions
        val keyWidth = entries.maxOf { textWidth(it.first) }
        val descWidth = entries.maxOf { textWidth(it.second) }
        val boxWidth = keyWidth + pad + descWidth + pad * 2
        val boxHeight = entries.size * lineHeight + pad * 2

        noStroke()
        fill(255f, 255f, 255f, 200f)
        rect(startX, startY, boxWidth, boxHeight)
        fill(0f)
        entries.forEachIndexed { i, (key, desc) ->
            val yPos = startY + pad + i * lineHeight
            text(key, startX + pad, yPos)
            text(desc, startX + pad + keyWidth + pad, yPos)
        }

        popStyle()
    }

    /**
     * Renders a status bar at the bottom showing properties of the single selected shape.
     * If zero or multiple shapes are selected, the bar is not shown.
     */
    private fun drawStatusBar() {
        if (shapeState.shapes.isNullOrEmpty()) return 
        // Find selected shapes
        val selected = shapeState.shapes!!.filterIsInstance<InteractiveShape>().filter { it.isSelected }
        if (selected.size != 1) return

        val shape    = selected.first()
        val worldBox = shape.boundingBoxAt(shape.origin)

        // Prepare formatted strings
        val widthText   = String.format("W: %.2f", worldBox.width)
        val heightText  = String.format("H: %.2f", worldBox.height)
        val originXText = String.format("X: %.2f", shape.inner.origin.x)
        val originYText = String.format("Y: %.2f", shape.inner.origin.y)
        val fill        = shape.inner.style.fill
        // Cast float channels to Int for integer formatting
        val rText = String.format("R: %3d", fill.red.toInt())
        val gText = String.format("G: %3d", fill.green.toInt())
        val bText = String.format("B: %3d", fill.blue.toInt())
        val aText = String.format("A: %3d", fill.alpha.toInt())

        // Fixed-column layout parameters
        val pad       = 8f
        val charCount = 12
        val spacing   = pad * 2

        pushStyle()
        textFont(createFont("Monospaced", 14f), 14f)
        textAlign(LEFT, CENTER)
        textSize(14f)

        // Calculate column width based on a sample of monospaced chars
        val sample      = "0".repeat(charCount)
        val columnWidth = textWidth(sample)

        val barHeight = textAscent() + textDescent() + pad * 2
        val barY      = height - barHeight

        noStroke()
        fill(0f, 0f, 0f, 150f)
        rect(0f, barY, width.toFloat(), barHeight)

        fill(255f)
        var xPos = pad
        val yPos = barY + barHeight / 2
        val columns = listOf(
            widthText, heightText,
            originXText, originYText,
            rText, gText, bText, aText
        )
        for (txt in columns) {
            val padded = if (txt.length <= charCount) txt.padEnd(charCount)
            else txt.take(charCount)
            text(padded, xPos, yPos)
            xPos += columnWidth + spacing
        }
        popStyle()
    }

    /**
     * Adds a specified number of shapes to the existing list of shapes.
     *
     * Delegates shape generation logic entirely to [FormFactory.produce].
     * The new shapes are appended to the current shapes list.
     *
     * @param generationParams The parameters for generating shapes, as defined in [GenerationParams].
     *   This includes `count` (must be > 0), `shapeType` (if null, random shapes are generated),
     *   `safe` (for bounds checking), and `size`/`origin` ([DistributionConfig]) settings.
     * @see FormFactory.produce
     * @see GenerationParams
     */
    fun addShapes(generationParams: GenerationParams) {
        require(generationParams.count > 0) { "Number of shapes to add must be > 0" }

        val newShapes = FormFactory().produce(
            generationParams = generationParams,
            sizeConfig       = generationParams.size,
            originConfig     = generationParams.origin,
        )
        shapeState.shapes = if (shapeState.shapes.isNullOrEmpty()) newShapes
                 else shapeState.shapes!!.toMutableList().apply { addAll(newShapes) }

        val typeDescription = generationParams.shapeType?.name?.lowercase()?.replaceFirstChar {
            if (it.isLowerCase()) it.titlecase() else it.toString()
        } ?: "random"

        println("\\nAdded ${generationParams.count} new ${typeDescription}(s). Total shapes: ${shapeState.shapes!!.size}")
        newShapes.forEach { println(it) }
    }

    /**
     * Handles key presses for various actions:
     *
     * - 'M' / 'm': Toggle between [RelativeScaleMapper] and [UniformScaleMapper].
     *   @see de.fhkiel.oop.mapper.RelativeScaleMapper
     *   @see de.fhkiel.oop.mapper.UniformScaleMapper
     *
     * - 'Q' / 'q': Add a new [Square] via [FormFactory.produce].
     *   @see de.fhkiel.oop.shapes.Square
     *   @see de.fhkiel.oop.config.GenerationParams.SQUARE
     *
     * - 'V' / 'v': Add a new [Rectangle] via [FormFactory.produce].
     *   @see de.fhkiel.oop.shapes.Rectangle
     *   @see de.fhkiel.oop.config.GenerationParams.RECTANGLE
     *
     * - 'K' / 'k': Add a new [Circle] via [FormFactory.produce].
     *   @see de.fhkiel.oop.shapes.Circle
     *   @see de.fhkiel.oop.config.GenerationParams.CIRCLE
     *
     * - 'R', 'G', 'B' (case‐sensitive): Adjust the **fill** color components of **all selected** shapes.
     *   Uppercase increases by 5 units; lowercase decreases by 5 units.
     *   Channels are clamped to [0..255].
     *   @see de.fhkiel.oop.model.Style
     *   @see de.fhkiel.oop.utils.Color
     *
     * - '0'..'9': Set the **stroke weight** (in pixels) of **all selected** shapes.
     *   Values below [Config.MIN_STRK_WEIGHT] (.5f) will be clamped to it.
     *   @see de.fhkiel.oop.config.Config.MIN_STRK_WEIGHT
     *
     * - 'D' / 'd': Toggle [Config.DEBUG].
     *   @see de.fhkiel.oop.config.Config
     *
     * - 'H' / 'h': Show the hint box for a longer duration.
     *   @see drawHint
     */
    override fun keyPressed() {
        // Convert key to uppercase for consistent handling
        if (keyCode.toChar() == DELETE) {
            if (shapeState.shapes.isNullOrEmpty()) {
                println("No shapes to delete.")
                return
            }
            val toRemove = shapeState.shapes!!
                .filterIsInstance<InteractiveShape>()
                .filter { it.isSelected }

            if (toRemove.isNotEmpty()) {
                shapeState.shapes = shapeState.shapes!!.toMutableList().apply { removeAll(toRemove) }

                if (interactionState.draggingShape != null && toRemove.contains(interactionState.draggingShape)) interactionState.draggingShape = null

                println("Deleted ${toRemove.size} shape(s). Remaining: ${shapeState.shapes!!.size}")
            }
            return
        }

        val selected = shapeState.shapes
            ?.filterIsInstance<InteractiveShape>()
            ?.filter { it.isSelected }
            .orEmpty()

        // Color adjustments using Color.increment*/decrement*
        when (key) {
            'R' -> selected.forEach { it.inner.style.fill = it.inner.style.fill.incrementRed() }
            'r' -> selected.forEach { it.inner.style.fill = it.inner.style.fill.decrementRed() }
            'G' -> selected.forEach { it.inner.style.fill = it.inner.style.fill.incrementGreen() }
            'g' -> selected.forEach { it.inner.style.fill = it.inner.style.fill.decrementGreen() }
            'B' -> selected.forEach { it.inner.style.fill = it.inner.style.fill.incrementBlue() }
            'b' -> selected.forEach { it.inner.style.fill = it.inner.style.fill.decrementBlue() }
        }

        // Stroke weight adjustment
        if (key in '0'..'9') {
            val weightPx = key.digitToInt().toFloat().coerceAtLeast(Config.MIN_STRK_WEIGHT)
            selected.forEach { it.inner.style.weight = weightPx }
            return
        }

        // Other shortcuts
        when (key.lowercaseChar()) {
            'm' -> mapperState.mapper =
                if (mapperState.mapper is RelativeScaleMapper) UniformScaleMapper(this, sketchConfig.baseWidth, sketchConfig.baseHeight)
                else RelativeScaleMapper(this, sketchConfig.baseWidth, sketchConfig.baseHeight, sketchConfig.baseMin)
            'q' -> addShapes(GenerationParams.SQUARE)
            'v' -> addShapes(GenerationParams.RECTANGLE)
            'k' -> addShapes(GenerationParams.CIRCLE)
            'd' -> Config.DEBUG = !Config.DEBUG
            'h' -> {
                hintConfig.startTime = millis()
                hintConfig.duration  = 15_000
            }
        }
    }

    /**
     * Handles mouse clicks to toggle selection of shapes.
     *
     * When the user clicks on a shape, it toggles its selection state.
     * If the SHIFT key is not pressed, all other shapes are deselected first.
     *
     * Uses hit detection based on the current [CoordinateMapper] to determine which shape was clicked.
     */
    override fun mousePressed() {
        if (shapeState.shapes.isNullOrEmpty()) {
            println("No shapes to select.")
            return
        }

        val mx = mouseX.toFloat()
        val my = mouseY.toFloat()
        // 1) Check if clicked on any handle of a selected shape
        run {
            shapeState.shapes!!
                .filterIsInstance<InteractiveShape>()
                .filter { it.isSelected }
                .forEach { ms ->
                    ms.getHandleScreenBounds(mapperState.mapper).forEachIndexed { idx, box ->
                        if (mx in box.origin.x..(box.origin.x + box.width) &&
                            my in box.origin.y..(box.origin.y + box.height)) {
                            // Begin resize
                            interactionState.resizingShape          = ms
                            interactionState.resizingHandleIndex    = idx
                            interactionState.initialBoundingBox     = ms.inner.boundingBoxAt(ms.inner.origin)
                            interactionState.initialOriginForResize = ms.inner.origin.copy()
                            return@run
                        }
                    }
                }
        }
        if (interactionState.resizingShape != null) return

        // Hit detection
        val hit = shapeState.shapes!!
            .filterIsInstance<InteractiveShape>()
            .asReversed()
            .firstOrNull { it.hitTestScreen(this.mapperState.mapper, mx, my) }

        // Handle selection toggle
        if (!keyPressed || keyCode != SHIFT)
            shapeState.shapes!!.filterIsInstance<InteractiveShape>().forEach { it.isSelected = false }

        hit?.let { ms ->
            ms.isSelected = !ms.isSelected

            if (ms.isSelected) {
                interactionState.draggingShape = ms
                val worldMouseVector = mapperState.mapper.screenToWorld(Vector2D(mx, my))
                interactionState.dragOffset = Vector2D(worldMouseVector.x - ms.inner.origin.x, worldMouseVector.y - ms.inner.origin.y)
            } else {
                interactionState.draggingShape = null
            }
        }
    }

    override fun mouseDragged() {
        val worldMouseVector = mapperState.mapper.screenToWorld(Vector2D(mouseX.toFloat(), mouseY.toFloat()))

        if (interactionState.resizingShape != null) {
            val ms = interactionState.resizingShape!!
            ms.inner.strategies.resizeStrategy.resize(
                ms.inner,
                interactionState.resizingHandleIndex,
                interactionState.initialBoundingBox!!,
                interactionState.initialOriginForResize!!,
                worldMouseVector
            )
            return
        }

        val ms = interactionState.draggingShape ?: return

        val desired = Vector2D(worldMouseVector.x - interactionState.dragOffset.x, worldMouseVector.y - interactionState.dragOffset.y)

        val clamped = ms.inner.strategies.constraints?.fold(desired) { accOrigin, strategy ->
            strategy.clampOrigin(accOrigin, ms.inner)
        } ?: desired

        try {
            ms.inner.origin = clamped
        } catch (e: Exception) {
            println("Error dragging shape: ${ms.inner.javaClass.simpleName} at $desired:\n${e.message}")
        }
    }

    override fun mouseReleased() {
        interactionState.draggingShape         = null
        interactionState.dragOffset            = Vector2D(0f, 0f)

        // Clear resize state - 
        interactionState.resizingShape         = null
        interactionState.resizingHandleIndex   = -1
        interactionState.initialBoundingBox    = null
        interactionState.initialOriginForResize= null
    }
}
